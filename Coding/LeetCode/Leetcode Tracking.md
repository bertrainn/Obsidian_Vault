---

---
# ðŸ§® LeetCode Problem Tracker

| #    | Problem Name                                                                                                                    | Difficulty | Algorithm Used              | Optimal Solution                                                                                                                                                                                                                                                                                |
| ---- | ------------------------------------------------------------------------------------------------------------------------------- | ---------- | --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 153  | [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)                     | Medium     | Binary Search               | Binary Search <br>check if the nums[middle] > nums[right], if it is close off l to middle + 1 else r = m<br>                                                                                                                                                                                    |
| 33   | [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)                                 | Medium     | Binary Search               | - Do a find min in rotated sorted array first to create a partition<br>- Find L, R pointers based on which partition the target is in<br>- Do regular BS within the partition                                                                                                                   |
| 875  | [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)                                                       | Medium     | Binary Search               | - L, R = 1 and max(amount possible), rate = (l + r) // 2<br>- Calc the total hours it takes to eat the piles at that rate.<br>- if total_time_taken <= h -> we too fast can go slower<br>- else total_time_taken > h -> we too slow go faster<br>return r                                       |
| 643  | [Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/)                                         | Easy       | Sliding Window (Fixed size) | - Build up the current sum (first k ele)<br>- iterate through the remaining ele with the fixed window <br>- cal and update the avg as you go along                                                                                                                                              |
| 1004 | [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)                                             | Medium     | Sliding Window (Dynamic)    | - keep track of max window, zero count<br>- Iterate through the list only caring about 0s -> opening the window<br>- check if 0 count is more than k <br>- if it is increment l (reducing the 0 count if nums\[l] is a 0) -> closing the window<br>- calc the window size and update max window |
| 3    | [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) | Medium     | Sliding Window (Dyanmic)    | - Use a set to keep track of chars in the substring<br>- iterate through the string<br>- if you encounter a dup, continually pop the left most character until the dup is gone <br>- add the char into the string and cal the substring length                                                  |
| 424  | [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)               | Medium     | Sliding Window (Dynamic)    | - Use a "map" to keep track of the number of char seen<br>- Keep adding elements into the count -> expand the window<br>- When the (window size) - (highest occurring char) > k -> no more replacements -> start popping from the left                                                          |
| 209  | [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)                                           | Medium     | Sliding Window              | - Read the fukin question JFC<br>- Keep adding values -> Opening the window<br>- Only start closing after total_sum >= target -> pop left and update accordingly                                                                                                                                |
| 567  | [Permutation in String](https://leetcode.com/problems/permutation-in-string/)                                                   | Medium     | Sliding Window              | - keep 2 maps (s1 and s2)<br>- append the char at r -> open window<br>- if the window is bigger than the len of s1 -> close the window <br>- if the 2 arrays == -> return True                                                                                                                  |
| 226  | [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)                                                         | Easy       | Tree (Binary Tree) DFS      | - do DFS on the root of the tree<br>- swap the left and right nodes<br>- Then DFS on left then right<br>- Return the root of the tree                                                                                                                                                           |
| 104  | [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)                                     | Easy       | Tree (Binary) DFS           | - Do DFS <br>- Return 1 + max(DFS(root left, root right))                                                                                                                                                                                                                                       |
| 110  | [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)                                                     | Easy       | Tree (Binary) DFS           | - Create a global Balanced variable to keep track of the whole tree<br>- do a "maximum depth" on left and right side to find the height of each branch<br>- check if the abs(left - right) > 1, if it is update the global balance                                                              |
| 543  | [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)                                               | Easy       | Tree (Binary) DFS           | - Keep a global max diameter viable<br>- Better to think of "building" the diameter from the bottom up -> basically cal the diameter for every node <br>- cal the left and right diameter<br>- update the max                                                                                   |
| 100  | [Same Tree](https://leetcode.com/problems/same-tree/)                                                                           | Easy       | Tree (Binary) DFS           | - Do DFS <br>- Compare the t1.val and t2.val <br>- Then compare the left and right nodes                                                                                                                                                                                                        |
| 101  | [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)                                                                 | Easy       | Tree (Binary) DFS           | - DFS<br>- Imagine having 2 pointers which iterate through the Tree<br>- Similar to "Same Tree"                                                                                                                                                                                                 |
| 112  | [Path Sum](https://leetcode.com/problems/path-sum/)                                                                             | Easy       | Tree (Binary) DFS           | - DFS <br>- Keep a running total (doing decremental iterations don't account for a empty list with target 0)<br>- check if the target == cur if it is the last node (i.e. no left and right child)                                                                                              |
|      | [Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)                                               | Easy       |                             |                                                                                                                                                                                                                                                                                                 |


# Random Notes
## Binary Search
l <= r:
-  Continuously searches while there's at least one element to check
- Checks the element when l == r
- used for finding exact values
- Used for
	- Finding specific values
	- Problems that might return **Not found**
	- When you need to examine every possibility 
l < r: 
- Stops when pointers meet
- doesn't check when l == r
- used for finding boundaries/ positions 
- Used for
	- Finding first/ last occurrences 
	- Finding insertion positions 
	- Problems where answers always exists 

